% SPDX-FileCopyrightText: 2024 Maxim Urschumzew <mxmurw@determi.io>
% SPDX-FileCopyrightText: 2024 Miëtek Bak
%
% SPDX-License-Identifier: MIT

\documentclass{scrartcl}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{mathpartir}
\usepackage[numbers]{natbib}
\usepackage{stmaryrd}
\usepackage[hyphens]{url}
\usepackage{xcolor}

% use microtype for advanced typography
\usepackage[activate={true,nocompatibility},
            final,
            tracking=true,
            kerning=true,
            spacing=true,
            factor=1100,
            stretch=10,
            shrink=10]{microtype}
\microtypecontext{spacing=nonfrench}
\SetTracking{encoding={*}, shape=sc}{0}
\urlstyle{same}
\definecolor{urlblue}{rgb}{0,0.2,0.8}

% use hyperref last to avoid problems
\usepackage{hyperref}
\hypersetup{
  allcolors=urlblue,
  bookmarksnumbered=false,
  bookmarksopen=false,
  breaklinks=true,
  colorlinks,
  pdfborder={0 0 0},
  pdfborderstyle={/S/U/W 1}
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\theoremstyle{definition}
\newtheorem{definition}{Definition}
\newtheorem{example}{Example}
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{conjecture}{Conjecture}

\newcommand{\primitive}[1]{\textsf{\textbf{#1}}}
\newcommand{\MTTM}{MTT${}_{\mathcal{M}}$}
\newcommand{\ChorMTT}{Chor${}_{\textrm{MTT}}$}
\newcommand{\ProcMTT}{Proc${}_{\textrm{MTT}}$}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\title{Kami: A modal type theory for~distributed~systems}
\author{Maxim Urschumzew \and Miëtek Bak}
\date{\today}
\begin{document}
\maketitle
\begin{abstract}\noindent
  We present Kami, a programming language for distributed systems based on
  Modal Type Theory\cite{gratzer2023syntax}. In particular, we describe a mode
  theory that is suitable for distributed programming, and show how the
  primitives of Chor$\lambda$\cite{cruz2022functional}, a choreographic
  programming language, can be recovered in Kami. Finally, we sketch a
  categorical semantics that gives rise to a generic compilation procedure for
  Kami.
\end{abstract}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Introduction}
Modalities provide a way to extend a type theory with domain-specific type
constructors, which can be used to track runtime properties of code directly in
the type system. For example, modalities have been used to represent
unevaluated code for metaprogramming and staged
computation\cite{davies2001modal}, and to encode the notion of location in
ML5\cite{murphy2008modal}, a language for distributed systems. In fact, the
\texttt{at} modality of ML5 serves the same purpose as the location annotations
in choreographic programming languages\cite{cruz2022functional,
giallorenzo2024choral}, and it stands to reason that existing research on
modalities could provide some stepping stones for the design of type systems
for choreographic programming languages.

In this paper, we explore how Chor$\lambda$\cite{cruz2022functional}, a
functional choreographic programming language, can be based on top of a simply
typed lambda calculus (STLC) with modalities, a variant of Modal Type
Theory\cite{gratzer2023syntax}. This requires the introduction of two new
concepts: common knowledge between multiple participants, and local knowledge
of global computations.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Preliminaries}
\subsection{\texorpdfstring{Chor$\lambda$}{ChorLambda}}
Chor$\lambda$\cite{cruz2022functional} is a functional choreographic
programming language introduced by Cruz-Filipe et~al., and an extension of STLC
with location annotations. For example, $t : \textsf{Bool} @ r$ means that $t$
evaluates to a value of type \textsf{Bool} located at role $r$. The language
has two communication primitives: \primitive{com} for communicating data and
\primitive{select} for communicating choice of branching.

\subsection{Modal Type Theory}
Modal Type Theory (MTT)\cite{gratzer2023syntax}, introduced by Gratzer in his
PhD dissertation, is a framework for constructing modal type theories, with
Martin-L\"{of} type theory at its core. The framework is parametrized by a
system of modalities specified in the form of a \emph{mode theory}. MTT
includes so-called ``full-spectrum'' dependent types, but we restrict ourselves
to a simply typed fragment of MTT.
\begin{definition}[{\cite[Chapter 6.1.1]{gratzer2023syntax}}]
  A \emph{mode theory} is given by the following data:
  \begin{itemize}
  \item
    A set of \emph{modes} $M$. Every mode $m \in M$ instantiates a distinct
    copy of an extension of STLC.
  \item
    For each pair of modes $m, n \in M$, a set $m \to n$ of \emph{modalities}
    between the modes. A modality $\mu : m \to n$ allows us to use types and
    terms of mode $m$ in mode $n$. There might be multiple distinct modalities
    $\mu , \nu : m \to n$.
  \item
    For every pair of modalities $\mu, \nu \in m \to n$ with matching domains
    and codomains, a set $\mu \Rightarrow \nu$ of \emph{transformations}
    between the modalities. A transformation $\alpha : \mu \Rightarrow \nu$
    allows us to convert types and terms from under the modality $\mu$ to under
    the modality $\nu$. There might be multiple distinct transformations
    $\alpha, \beta : \mu \Rightarrow \nu$.
  \end{itemize}
  Concretely, this data forms a 2-category, in the sense that identity
  modalities (of type $id_m : m \to m$) and identity transformations (of type
  $id_\mu : \mu \Rightarrow \mu $) exist, modalities and transformations can be
  composed (denoted by $\mu \fatsemi \nu$ and $\alpha \fatsemi \beta$
  respectively) if the domains and codomains match, and identity and
  associativity laws hold as expected\cite{licata2016adjoint}.
\end{definition}

\begin{definition}[{\cite[following Chapter 6.2]{gratzer2023syntax}}]
  Let $\mathcal{M}$ be a mode theory. A \emph{simply typed modal type theory}
  \MTTM{} is given by $|M|$ copies of an extension of STLC, combined as
  follows: For each mode $m \in M$, let $\Gamma\in\textsf{Ctx}_m$, $A \in
  \textsf{Type}_m$, $t \in \textsf{Term}_m$, and $\Gamma \vdash_m t : A$ denote
  the contexts, types, terms, and typing judgements of the $m$th copy of an
  extension of STLC respectively.
  
  The rules of \MTTM{} are displayed in figures \ref{fig:mtt_type},
  \ref{fig:mtt_ctx}, \ref{fig:mtt_var}, and \ref{fig:mtt_term}.
\end{definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Types
\begin{figure}
  \centering
  \begin{mathpar}
    \inferrule*[Lab=Mod]
    {
      A \in \textsf{Type}_m
      \\
      \mu : m \to n
    }
    {\langle A | \mu \rangle \in \textsf{Type}_n}

    \inferrule*[Lab=Fun]
    {
      A \in \textsf{Type}_m
      \\
      \mu : m \to n
      \\
      B \in \textsf{Type}_n
    }
    {(A | \mu) \to B \in \textsf{Type}_n}
    \\
    \inferrule*[Lab=Prod]
    {
      A \in \textsf{Type}_m
      \\
      B \in \textsf{Type}_m
    }
    {A \times B \in \textsf{Type}_m}

    \inferrule*[Lab=Sum]
    {
      A \in \textsf{Type}_m
      \\
      B \in \textsf{Type}_m
    }
    {A + B \in \textsf{Type}_m}
  \end{mathpar}
  \caption{Well moded types of \MTTM{}}
  \label{fig:mtt_type}
\end{figure}

\subsubsection*{Well moded types}
Types of \MTTM{} (figure \ref{fig:mtt_type}) mirror the standard types of STLC,
with the following differences:
\begin{itemize}
\item
  A \emph{modal type} $\langle A | \mu \rangle \in \textsf{Type}_n$ is formed by
  lifting a type $A \in \textsf{Type}_m$ to mode $n$ using a modality $\mu : m
  \to n$.
\item
  A \emph{modal function type} $(A | \mu) \to B$ is formed for each type $A :
  \textsf{Type}_m$, $B : \textsf{Type}_n$, and modality $\mu : m \to n$. This
  type is a convenience that behaves as the standard function type composed
  with a modal type. We recover the standard function type using the identity
  modality $id_m : m \to m$.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Contexts
\begin{figure}
  \centering
  \begin{mathpar}
    \inferrule*[Lab=Ctx-Empty]
    {\textrm{ }}
    {\varepsilon \in \textsf{Ctx}_m}

    \inferrule*[Lab=Ctx-Ext]
    {
      \Gamma \in \textsf{Ctx}_n
      \\
      A \in \textsf{Type}_m
      \\
      \mu : m \to n
    }
    {\Gamma.(A|\mu) \in \textsf{Ctx}_n}
    
    \inferrule*[Lab=Ctx-Restr]
    {
      \Gamma \in \textsf{Ctx}_n
      \\
      \mu : m \to n
    }
    {\Gamma.\{\mu\} \in \textsf{Ctx}_m}
  \end{mathpar}
  \caption{Well moded contexts of \MTTM{}}
  \label{fig:mtt_ctx}
\end{figure}
  
\subsubsection*{Well moded contexts}
Contexts of \MTTM{} (figure \ref{fig:mtt_ctx}) are defined as follows:
\begin{itemize}
\item
  The empty context rule \textsc{Ctx-Empty}.
\item
  The context extension rule \textsc{Ctx-Ext} says that all assumptions in a
  context $\Gamma \in \textsf{Ctx}_m$ must exist at a mode $m$, but they may
  originate at a different mode $n$ by way of a modality $\mu : n \to m$. This
  means that an assumption in a context $\Gamma$ is of the form $(A | \mu) \in
  \Gamma$, where $A$ is a type, $n$ is an arbitrary mode, and $\mu : n \to m$
  is a modality that brings the assumption into mode $m$. If the assumption
  originates at the current mode, then $\mu = id_m : m \to m$.
\item
  The context restriction rule \textsc{Ctx-Restr} allows us to restrict the use
  of assumptions to those under a particular modality. That is, starting with a
  context $\Gamma \in \textsf{Ctx}_n$ and a pair of modalities $\mu, \nu : m
  \to n$, the restricted context $\Gamma.\{\nu\}\in\textsf{Ctx}_m$ only allows
  referring to the assumption $(A | \mu) \in \Gamma$ given a transformation
  $\alpha : \mu \Rightarrow \nu$. This is ensured by the variable rule
  \textsc{Var} (figure \ref{fig:mtt_term}).
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Variables
\begin{figure}
  \centering
  \begin{mathpar}
    \inferrule*[Lab=Var-Zero]
    {\ }
    {\primitive{zero}:(A|\mu) \in_{\textsf{id}} \Gamma.(A | \mu)}

    \inferrule*[Lab=Var-Suc]
    {x:(A|\mu) \in_{\nu} \Gamma}
    {\primitive{suc\ }x:(A|\mu) \in_{\nu} \Gamma.(B | \eta)}
    
    \inferrule*[Lab=Var-Restr]
    {x:(A|\mu) \in_{\nu} \Gamma}
    {x:(A|\mu) \in_{\eta \fatsemi \nu} \Gamma.\{\eta\}}
  \end{mathpar}
  \caption{Well typed variables (de Bruijn indices) of \MTTM{}}
  \label{fig:mtt_var}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Terms
\begin{figure}
  \centering

  \begin{mathpar}
    \inferrule*[Lab=Var]
    {
      x:(A|\mu) \in_\nu \Gamma
      \\
      \alpha : \mu \Rightarrow \nu
    }
    {\Gamma \vdash x^\alpha : A}
    \\
    \inferrule*[Lab=Mod-Intro]
    {\Gamma.\{\mu\} \vdash_m t : A}
    {\Gamma \vdash_n \primitive{mod\ }t : \langle A | \mu \rangle}

    \inferrule*[Lab=Mod-Elim]
    {
      \Gamma \vdash_m t : \langle A | \mu \rangle
      \\
      \Gamma.(x : A|\mu) \vdash_m s : B
    }
    {
      \Gamma \vdash_m \primitive{letmod}\ x \leftarrow t\ \primitive{in}\ s : B
    }
    \\
    \inferrule*[Lab=Fun-Intro]
    {\Gamma.(x : A|\mu) \vdash_n t : B}
    {\Gamma \vdash_n \lambda x.t : (A | \mu) \to B}

    \inferrule*[Lab=Fun-Elim]
    {\Gamma \vdash_n f : (A | \mu) \to B
      \\
      \Gamma \vdash_m x : A
    }
    {\Gamma \vdash_m f\ x : B}
    \\
    \inferrule*[Lab=Prod-Intro]
    {\Gamma \vdash_m a : A
      \\
      \Gamma \vdash_m b : B
    }
    {\Gamma \vdash_m (a\,\primitive{,}\,b) : A \times B}

    \inferrule*[Lab=Prod-Fst]
    {\Gamma \vdash_m x : A \times B}
    {\Gamma \vdash_m \primitive{fst } x : A}

    \inferrule*[Lab=Prod-Snd]
    {\Gamma \vdash_m x : A \times B}
    {\Gamma \vdash_m \primitive{snd } x : B}
    \\
    \inferrule*[Lab=Sum-Left]
    {\Gamma \vdash_m x : A}
    {\Gamma \vdash_m \primitive{left } x : A + B}

    \inferrule*[Lab=Sum-Right]
    {\Gamma \vdash_m x : B}
    {\Gamma \vdash_m \primitive{right } x : A + B}

    \inferrule*[Lab=Sum-Elim]
    {\Gamma \vdash_m x : A + B
      \\
      \Gamma.(a : A|\textsf{id}) \vdash_m t : C
      \\
      \Gamma.(b : B|\textsf{id}) \vdash_m s : C
    }
    {\Gamma \vdash_m \primitive{case } x \primitive{ of } \{ \primitive{left } a
      \mapsto t ; \primitive{right } b \mapsto s \}: C}
    % \\
    % \inferrule*[Lab=Nat-Zero]
    % {\textsf{ }}
    % {\Gamma \vdash_m \primitive{zero} : \mathbb{N}}

    % \inferrule*[Lab=Nat-Suc]
    % {\Gamma \vdash_m n : \mathbb{N}}
    % {\Gamma \vdash_m \primitive{suc } n : \mathbb{N}}

    % \inferrule*[Lab=Nat-Elim]
    % {\Gamma \vdash_m n : \mathbb{N}}
    % {\Gamma \vdash_m \primitive{suc } n : \mathbb{N}}
\end{mathpar}
  \caption{Well typed terms of \MTTM{}}
  \label{fig:mtt_term}
\end{figure}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% XXX TODO XXX
% The introduction rule \textsc{Mod-Intro} enforces that
% terms of such a modal type may only depend on variables that are themselves
% under the $\mu$ modality. The elimination rule \textsc{Mod-Elim} allows us to
%assume that we have a variable $x : (A|\mu)$ in order to eliminate from
%$\langle A | \mu \rangle$.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsubsection*{Well typed terms}
Terms of \MTTM{} (figure \ref{fig:mtt_term}) differ from terms of STLC as
follows:
\begin{itemize}
\item
  There are new terms for introduction and elimination of modal types
  (\textsc{Mod-Intro} and \textsc{Mod-Elim}).
\item
  The function introduction rule (\textsc{Fun-Intro}) preserves the additional
  modality by putting it into the context, alongside the new variables' type.
\item
  The function elimination rule (\textsc{Fun-Intro}) deals with its modality
  annotation by restricting the context with it.
\item
  All other terms are mode-local and all occuring modalities are required to be
  identities.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Choreographic programming with MTT}
The first, essential feature of modalities in MTT is that they restrict code availability:
When constructing a term of type $\langle A | \mu \rangle$, only
variables that are themselves under a $\mu$ modality can be used. This leads
us naturally to the idea that we can use MTT for a distributed system with a set of
participating roles $\rho$ by introducing modalities $@r$ for each role $r \in
\rho$. The type $\langle A | @r \rangle$ then is interpreted as ``data of type
$A$, located at role $r$''.

\medskip

The second feature of MTT is that transformations between
modalities can be introduced in a controlled way. In order to allow a term at
role $r$ to be transformed into a term at role $s$, we simply have to introduce
a transformation $\tau_{r,s} : @r \Rightarrow @s$ between the corresponding
modalities. These transformations can be chosen freely: we might disallow
communications between some nodes and include multiple channels between some others.

\subsection{A mode theory for choreographic programming}

However, a mode theory with only $@$-modalities and transformations $\tau_{r,s}$
is not enough to recover the full expressive power of
Chor$\lambda$. In particular, expressing the \textbf{select} operator, which is
used to notify other roles about decisions that happened locally at node $r$,
requires the following additional features:
\begin{enumerate}
\item We
  need modalities expressing the fact that some data is ``common knowledge'' of
  multiple roles. We do so by allowing arbitrary conjunctions $r_1 \land \ldots
  \land r_k$ in the modality. For example, the type $\langle \mathbb{N} |
  @(r\land s) \rangle$ expresses the fact that there is a natural number that is
  known by both roles $r$ and $s$.
\item We need roles to reference data that is about to be sent to other
  nodes. For this we use a new modality $\square$\footnote{Usually this symbol
    is pronounced ``box'', but we also refer to it by ``quote''.}, which allows roles to
  reference global choreographies locally. That is, if $A$
  is a global choreography type, then $t : \langle A | \square \rangle$ is a
  local term, containing a quoted representation of such a choreography.
\end{enumerate}
We define our mode theory with $@$ and $\square$ modalities and common knowledge
locations as follows:
\begin{definition}
Let $\rho$ be a set of roles and $\textrm{Loc}_\rho$ be the freely generated
meet-semilattice on $\rho$. The mode theory
$\mathcal{M}^\rho_{\textrm{Chor}}$ is defined as follows:

\begin{itemize}
\item There are two modes: $\circ$ and
  $\triangle$. The global mode $\circ$ represents the
  global perspective on a choreography, encompassing computations and data
  occuring at all roles. The local mode $\triangle$
  represents the perspective of a single location (which might be the
  conjunction of multiple roles) participating in the choreography.
\item For each location $u \in \textrm{Loc}_\rho$ there is a modality $@u : \triangle \to
  \circ$. Each of these modalities represents a different way of how a local
  computation can be embedded in the global system. Concretely, $@u$ expresses
  that the computation exists at location $u$.
\item An additional modality $\square : \circ \to \triangle$, allowing global
  computations to be referenced locally.
\item For each location $u \in \textrm{Loc}_\rho$, a transformation
  $\textsf{prepare}_u : \textsf{id}_\triangle \Rightarrow ({}@ u ;
  \square)$. This transformation allows a process to prepare a local term to be evaluated by an
  arbitrary role $u$. It happens in local mode ($\triangle$) and its
  interpretation involves no communication.
\item For each location $v \in \textrm{Loc}_\rho$, a transformation
  $\textsf{eval}_v : (\square ; {}@ v) \Rightarrow \textsf{id}_\circ$. This
  transformation is the only one involving communication between roles. It
  describes that a global choreography, available in quoted form at location
  $v$, can be scheduled to be executed by all involved roles.
\item For each pair of locations $u, v \in \textrm{Loc}_\rho$ with $u \leq v$, a
  transformation $\textsf{narrow}_{u,v} : @u \Rightarrow @v$.
\item Additional equalities governing the interactions of the transformations.
  For instance, composing $\textsf{prepare}_u$ and $\textsf{eval}_u$ for
  the same role $u$ is equal to the identity transformation since it represents
  a process communicating with itself.
\end{itemize}
\end{definition}
\begin{corollary}
  In {\upshape$\mathcal{M}^{\rho}_{\textrm{Chor}}$}, it is possible to recover a transformation
  $\tau_{u,v} : @u \Rightarrow @v$ by composing {\upshape$\textsf{prepare}_v$}
  and {\upshape$\textsf{eval}_u$}. Additionally, a process communicating with
  itself is equal to the identity, {\upshape$\tau_{u,u} = \textsf{id}_u$}.
\end{corollary}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Kami: An MTT based language for choreographic programming}


Our mode theory expresses the interactions
between participating roles in a distributed system, but standard MTT
instantiated with $\mathcal{M}^{\rho}_{\textrm{Chor}}$ is not suitable to be used as a choreographic
programming language. The problem is that there is no notion of
deferred transformations: transformations are always pushed down the syntax
tree as far as possible and only recorded at the variables. This means that in
order to control the communication behaviour of terms, we need to introduce a
dedicated term for not yet executed communications.
In our semantics only $\textsf{eval}_v$ involves
communications, so we simply add a dedicated term representing it. Its typing and
reduction rules are displayed in figure \ref{fig:mtt_leteval}.

\begin{figure}
  \centering
  \begin{mathpar}
    \mprset{fraction={---},fractionaboveskip=0ex,fractionbelowskip=1ex}
    \inferrule*[Lab=Let-Eval]
    {
      \Gamma \vdash t : \langle A | \square ; @v \rangle
      \\
      \Gamma.(x : A|\textsf{id}_\circ) \vdash s : B
    }
    {
      \Gamma \vdash \primitive{leteval}_v\ x
        \leftarrow t\ \primitive{in}\ s : B
    }
    \\
    \inferrule*[Lab=Let-Eval-$\beta$]
    {
    }
    {
      \Gamma \vdash \primitive{leteval}_v\ x \leftarrow
        t\ \primitive{in}\ s \rightsquigarrow \Gamma \vdash \primitive{mod}\ y
        \leftarrow t\ \primitive{in}\ s [ x / y^{\textsf{eval}_v} ]
    }
  \end{mathpar}
  \caption{Typing and reduction rule for deferred transformations.}
  \label{fig:mtt_leteval}
\end{figure}

\medskip


\begin{definition}
  Let Chor${}_{\textrm{MTT}}$ be the type theory obtained by:
  \begin{enumerate}
  \item Initializing simply typed MTT with $\mathcal{M}^{\rho}_{\textrm{Chor}}$.
  \item Extending it with the \textsc{Let-Eval} rule.
  \item Restricting the reduction relation analogously how Chor$\lambda$
    restricts the reduction relation of STLC.
  \end{enumerate}
\end{definition}

\subsection{Behavioural semantics and relation with \texorpdfstring{Chor$\lambda$}{ChorLambda}}

In order to allow for out-of-order execution of of independent processes, we can use
the same machinery as Chor$\lambda$: restricting reduction rules to ensure that
communications between a pair of processes always occur in the same order and an
additional rewriting relation that allows for independent processes to evaluate
their terms independently.

The expressivity of Chor$\lambda$ arises from the two primitives involved in
process interaction: $\primitive{com}$ and $\primitive{select}$. Communication is
easily reproduced in \ChorMTT{} by using $\textsf{prepare}$ and $\textsf{eval}$.
\begin{example}
In \ChorMTT, we can define a function $\textsf{com}_{A,u,v} : \langle A | @u
\rangle \to \langle A | @v \rangle$ for each local type $A$ and pair of locations
$u,v$.
\begin{align*}\setlength{\jot}{0.5ex}
  \textsf{com}_{A,u,v}\ a =
  \ & \primitive{letmod}\ a_1 \leftarrow a\\
    & \primitive{leteval}_u\ a_2 \leftarrow
        \primitive{mod}\ a_1^{\textsf{prepare}_v * \textsf{id}_{@u}}\\
    & \primitive{in}\ \primitive{mod}\ a_2^{\textsf{id}}
\end{align*}
\end{example}
Selection in Chor$\lambda$ works as follows: a process at role $r$
chooses its future behaviour based on locally available data and afterwards
communicates its choice using \primitive{select} statements to those processes that need to
be aware of this choice. In \ChorMTT{} the same functionality is available, but has
to be stated in reverse order. First the required data for choosing future
behaviour is communicated from $r$ to all roles that need to be aware of this
choice. After receiving the data, all relevant processes synchronously decide
their future behaviour.
\begin{example}
  Let $A, B$ be local types, and $Z$ a global type. A function of the following
  type can be derived in \ChorMTT:
  \[
    \textsf{choice}_{A,B,Z,r} : \langle A + B | @r \rangle
    \to (\langle A | @r \rangle \to Z)
    \to (\langle B | @r \rangle \to Z)
    \to Z
  \]
  Note that since $Z$ is global, a value $z : Z$ is a choreography involving
  possibly all roles\footnote{For the sake of brevity our mode theory
    $\mathcal{M}^{\rho}_{\textrm{Chor}}$ as defined in this paper does not track which
    roles are actually involved in a given term of global type. It can be done
    though by extending the mode theory with a family of global modes.}. The semantics
  of $\textsf{choice}$ is: Given the knowledge of $A + B$ at role $r$, a global behaviour
  $z : Z$ can be chosen for all roles, with the additional knowledge of either
  the value $a : A$ or $b : B$ at role $r$. The function can be implemented in
  such a way that only the information regarding which branch is going to be
  chosen is communicated from $r$ to other processes, the actual value of $a$ or
  $b$ stays at $r$.

  The interaction of the $\square$ and $@r$ modalities are key to the definition
  of choice. In \cite{gratzer2023syntax} such a function that allows induction ``from under a
  modality'' is called a \emph{crisp induction principle}.
\end{example}

\subsection{Categorical semantics}
Following Gratzer, a categorical model for MTT$_{\mathcal{M}}$ is given by a
functor $F : \mathcal{M}^{\textsf{coop}} \to \textbf{Cat}$, with additional
conditions ensuring that $F$ supports all type formers and their terms. This
definition entails, for each modality $\mu : m \to n$, a functor
$F(\mu) : F(n) \to F(m)$ modeling the \emph{contravariant} context restriction
operation ${-}.\{\mu\} : \textsf{Ctx}_n \to \textsf{Ctx}_m$. Additionally, the
existence of modal types in Gratzer's model implies the existence of a further
\emph{covariant} functor $M_\mu : F(m) \to F(n)$, such that $F(\mu)$ and
$M_\mu$ are ``adjoint'' in an appropriate sense\footnote{In the dependently
  typed MTT of Gratzer the exact statement is that $M_\mu$ is a
  \emph{dependent right adjoint}, but we can simplify the condition somewhat
  in our simply typed case.}.

While such a generic Model of MTT is required for Gratzer's goals, our intended
semantics, in particular the fact that we want to compile Kami programs into
real-world executables leads us to considering a less general, but more
specifically useful class of models.

In the following we give the definition of our special class of models and
sketch how MTT${}_{\mathcal{M}^\rho_{\textrm{Chor}}}$, i.e., the underlying type
theory of Kami can be interpreted in them.

\begin{definition}
  Let $\mathcal{M}$ be a mode theory. A \emph{covariant model} for
  simply typed MTT$_{\mathcal{M}}$ is given by the following data:
  \begin{enumerate}
  \item A category $\mathcal{C}$ representing the compilation target.
  \item Closure of $\mathcal{C}$ under all type and term formers of MTT.
  \item A (covariant) 1-functor $G : \mathcal{M} \to \textbf{Cat}$ modeling the semantics of
    individual modes, and the modal types between them.
  \item A family of 1-functors $\iota_m : G(m) \to \mathcal{C}$, where $m \in
    \mathcal{M}$, describing how the category $G(m)$ is represented in the
    compilation target category.
  \item For each transformation $\alpha : \mu \Rightarrow \nu \in \mathcal{M}$,
    a natural transformation
    $\tau_\alpha : \iota_m \circ G(\mu) \Rightarrow \iota_m \circ G(\nu)$ in the
    target category.
  \end{enumerate}
\end{definition}

Such a covariant model is a special case of a contravariant model in the sense of Gratzer; we claim:

\begin{conjecture}
  A covariant model of MTT$_{\mathcal{M}}$ can be assembled into a contravariant
  model, by freely adjoining context restriction operators.
\end{conjecture}

\medskip

For our concrete use-case, we intend to obtain a covariant model as follows:

Let $\rho$ be a finite set of roles and let $\textbf{STLC}$ be the syntax
category of STLC with sum types. Viewing the set
$\rho$ as a discrete category, we denote by $\textbf{STLC}^\rho$ the functor
category $\rho \to \textbf{STLC}$. That is, an object $(\Gamma_i)_{i\in\rho}$
is a $\rho$-indexed family of $\textbf{STLC}$-contexts and a morphism
$(\Gamma_i)_{i\in\rho} \to (\Delta_i)_{i\in\rho}$ is given by a $\rho$-indexed
family of substitutions $(\sigma_i : \Gamma_i \to \Delta_i)_{i\in\rho}$. The
intuition is that $\textbf{STLC}^\rho$ describes the category of $\rho$
processes running independently of each other, with no way to interact. To
further add synchronous communication, we freely adjoin arrows axiomatizing
such. To properly express these arrows, we need the following definition:

\begin{definition}
  Let $i\in\rho$ be a role, define
  \begin{align*}
    \delta_i({-}) : \textbf{STLC} &\to \textbf{STLC}^\rho \\
    X &\mapsto j \mapsto \begin{cases}j = i \implies &X\\j \neq i \implies &1 \end{cases}
  \end{align*}
  to be the function mapping an object $X \in \textbf{STLC}$ to a family
  $X_j$, whose $i$th component is $X$, and all other components are the
  terminal object.
\end{definition}

\begin{definition} Define
  \begin{align*}
    [{-}] : \textbf{STLC}^\rho &\to \textbf{STLC} \\
    (Y_j)_{j\in\rho} &\mapsto \prod_{j \in \rho} Y_j
  \end{align*}
  to be the function mapping a family $(Y_j)_{j\in\rho} \in \textbf{STLC}^\rho$
  to the product of its components.
\end{definition}

With these definitions in hand, we can represent the type of a hypothetical
communication operation that communicates a global state $X \in
\textbf{STLC}^\rho$ from all processes to a single process $i \in \rho$ as follows:
\[
  \textsf{com}_{X,i} : X \to \delta_i([X])
\].

\begin{definition}
  Let the \emph{category of synchronously interacting processes},
  $\textbf{SyncIntProc}_{\mathcal{C}} = \textbf{STLC}^\rho[\textsf{com}]$
  be defined as the category
  $\textbf{STLC}^\rho$ of independent processes with freely adjoined arrows of
  the shape $\textsf{com}_{X,i} : X \to \delta_i([X])$ for any $X \in
  \textbf{STLC}^\rho$ and $i \in \rho$.
\end{definition}

\begin{theorem}
  Let $\mathcal{C}$ be a cartesian closed category. There is a covariant model
  of MTT${}_{\mathcal{M}^\rho_{\textrm{Chor}}}$ that has
  $\textbf{SyncIntProc}_{\mathcal{C}}$ as its compilation target category.
\end{theorem}

In particular, in this model, only the transformation $\textsf{eval}_v : (\square ;
{}@ v) \Rightarrow \textsf{id}_\circ$ is built up from the freely adjoined
$\textsf{com}$ arrows, since it is the only one involving communication. All
other transformations are modeled by arrows already existing as part of the
cartesian closed structure of each processes' individual category $\mathcal{C}$.

\begin{corollary}
  There is a translation function from the syntax category of
  MTT${}_{\mathcal{M}^\rho_{\textrm{Chor}}}$ to $\textbf{SyncIntProc}_{\mathcal{C}}$.
\end{corollary}
In other words, this gives us a compilation procedure for Kami programs into any
target language with cartesian closed categorical semantics and synchronous communication primitives.



\bibliographystyle{plainnat}
\bibliography{main}

\end{document}

